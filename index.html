<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="https://unpkg.com/spritejs/dist/spritejs.min.js"></script>
  <script src="/blockly/blockly_node_javascript_cn.js"></script>
  <script src="/dist/spritly.js"></script>
  <style>
    html, body {
      width: 100%;
      min-width: 600px;
      height: 100%;
      padding: 0;
      margin: 0;
    }
    #main {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: space-between;
    }
    #controls {
      position: absolute;
      right: 10px;
      top: 10px;
      z-index: 9999;
    }
    #controls button {
      cursor: pointer;
    }
    #blocklyDiv {
      height: 100%;
      width: 62%;
      border: none;
    }
    #displayDiv {
      width: 38%;
      margin-left: 20px;      
    }
    #stage {
      height: 70%;
      background: url(res/img/grid.jpg) repeat;
    }
    #stage iframe {
      width: 100%;
      height: 100%;
    }
    #links {
      padding: 30px;
      display: flex;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="showXml()">Blocks</button>
    <button onclick="showCode()">Code</button>
    <button onclick="window.frames[0].location.href = `sandbox.html?t=${Date.now()}`">Run</button>
  </div>
  <div id="main">
    <div id="blocklyDiv"></div>
    <div id="displayDiv">
      <div id="stage">
        <iframe frameborder="no"></iframe>
      </div>
      <div id="links">
        <a href="#index">index</a>
      </div>
    </div>
  </div>

  <script>
  (async function () {
    const {Blockly, initWorkspace, Dropdown} = spritly;

    let preload_res = null,
      workspace = null,
      toolbox = null;

    const update = debounce(() => {
      window.frames[0].location.href = `sandbox.html?t=${Date.now()}`;
    });

    async function loadStartBlocks() {
      if(workspace) workspace.dispose();

      const hash = window.location.hash || '#';
      const blockFile = hash.slice(1) || 'index';
      const blockXml = await fetch(`blocks/${blockFile}.xml`)
        .then(res => res.text())
        .then(str => (new DOMParser()).parseFromString(str, 'text/xml'));

      toolbox = blockXml.documentElement.getAttribute('toolbox') || 'toolboxs/default.xml';
  
      const toolboxXml = await fetch(toolbox)
        .then(res => res.text())
        .then(str => (new DOMParser()).parseFromString(str, 'text/xml'));

      preload_res = Array.from(blockXml.querySelectorAll('preload resource')).map((res) => {
        const type = res.getAttribute('type');
        if(type === 'texture_packer') {
          const texture = res.getAttribute('texture');
          const data = res.getAttribute('data');
          return [texture, data];
        }

        const src = res.getAttribute('src');
        const id = res.getAttribute('id') || src;
        return {id, src};
      });

      workspace = initWorkspace('blocklyDiv',
        {
          media: 'res/media/',
          toolbox: toolboxXml.documentElement,
          grid: {spacing: 25,
            length: 3,
            colour: '#ccc',
            snap: true,
          },
          zoom: {
            controls: true,
            wheel: true,
          },
        });

      Blockly.Xml.domToWorkspace(blockXml.documentElement,
        workspace);

      workspace.getAllBlocks().forEach((block) => {
        const parent = block.getParent();
        if(!parent) { // is root block
          const isCollapsed = block.isCollapsed();
          if(isCollapsed) setCollapsedAll(block, true);
        }
      });

      let lastClickedTime = null;
      workspace.addChangeListener((event) => {
        if(event.type === Blockly.Events.UI && event.element === 'click') {
          const clickedTime = Date.now();
          if(lastClickedTime && clickedTime - lastClickedTime <= 300) {
            lastClickedTime = null;
            const block = workspace.getBlockById(event.blockId);
            const isCollapsed = block.isCollapsed();
            const parent = block.getParent();
            if(!parent) {
              setCollapsedAll(block, !isCollapsed);
            }
            block.setCollapsed(!isCollapsed);
          }
          lastClickedTime = clickedTime;
        }
        if(event.type === Blockly.Events.CHANGE && event.element !== 'collapsed'
        || event.type === Blockly.Events.CREATE
        || event.type === Blockly.Events.DELETE
        || event.type === Blockly.Events.MOVE && event.oldParentId !== event.newParentId) {
          update();
        }
        if(event.type === Blockly.Events.CHANGE && event.element === 'collapsed') {
          const block = workspace.getBlockById(event.blockId);
          const parent = block.getParent();
          if(!parent) {
            const isCollapsed = event.newValue;
            setCollapsedAll(block, isCollapsed);
          }
        }
      });

      window.workspace = workspace;
    }

    function getCode() {
      const xml = Blockly.Xml.workspaceToDom(workspace);
      // Add each top block one by one and generate code.
      const allCode = [];
      let procedures = '';

      const signal_lists = xml.querySelectorAll('block[type="signal_onevent_send"] > field[name="SIGNAL"]');
      signal_lists.forEach((sig) => {
        Dropdown.set('Signals', sig.textContent);
      });

      const sprite_name_lists = xml.querySelectorAll('block[type="sprite_create_attrs"] > field[name="NAME"]');
      sprite_name_lists.forEach((name) => {
        Dropdown.set('SpriteNames', name.textContent);
      });

      const foreach_items = xml.querySelectorAll('block[type="list_foreach"] > field[name="ITEM"]');
      foreach_items.forEach((name) => {
        Dropdown.set('ListItems', name.textContent);
      });

      // Find and remove all top blocks.
      const topBlocks = [];
      for(let i = xml.childNodes.length - 1; i >= 0; i--) {
        const block = xml.childNodes[i];
        // console.log(block.lastChild);
        if(block.tagName === 'BLOCK') {
          const type = block.getAttribute('type');
          xml.removeChild(block);
          if(type === 'signal_do') {
            const signal = block.querySelector('field').textContent || 'START';
            topBlocks.unshift({block, type, signal});
          } else if(type === 'signal_new_sprite_as_receiver') {
            const signal = block.querySelector('field[name="SIGNAL"]').textContent || 'START';
            const nodeType = block.querySelector('field[name="RECEIVER"]').textContent || 'Sprite';
            const id = block.querySelector('field[name="ID"]').textContent;
            Dropdown.set('Sprites', id);
            topBlocks.unshift({block, type, signal, nodeType, id});
          } else if(type === 'signal_when_receiver_is') {
            const signal = block.querySelector('field[name="SIGNAL"]').textContent || 'START';
            const id = block.querySelector('field[name="ID"]').textContent;
            topBlocks.unshift({block, type, signal, id});
          } else if(type === 'procedures_defreturn') {
            topBlocks.unshift({block, type});
          }
        }
      }
      // Generate JavaScript code and run it.
      window.LoopTrap = 1e7;
      Blockly.JavaScript.INFINITE_LOOP_TRAP = `${Blockly.Generator.prototype.INDENT}if (--window.LoopTrap == 0) throw "Infinite loop.";\n`;

      for(let i = 0; i < topBlocks.length; i++) {
        const {block, type, signal} = topBlocks[i];
        const headless = new Blockly.Workspace();
        xml.appendChild(block);
        Blockly.Xml.domToWorkspace(xml, headless);
        const indent = Blockly.Generator.prototype.INDENT;

        let code = Blockly.JavaScript.workspaceToCode(headless);

        if(type === 'procedures_defreturn') {
          procedures = code;
          continue; // eslint-disable-line
        }

        code = indent + code.split(/\n/g)
          .join(`\n${indent}`).trimRight();

        const head = `spritly.runtime.Signal.on('${signal}', async function(sender, data){`;
  
        let receiver;
        if(type === 'signal_new_sprite_as_receiver') {
          const {nodeType, id} = topBlocks[i];
          receiver = `${Blockly.Generator.prototype.INDENT}let receiver = spritly.runtime.ElementList.getElementById('${id}');
  if(receiver == null){
    receiver = spritejs.createElement('${nodeType}', {id: '${id}'});
    spritly.runtime.ElementList.add(receiver);
  }`;
        } else if(type === 'signal_when_receiver_is') {
          const {id} = topBlocks[i];
          receiver = `const receiver = spritly.runtime.ElementList.getElementById('${id}');
  if(receiver == null) return;`;
        } else {
          receiver = '  let receiver = null;';
          code = `  if(target && receiver == null) {
    receiver = target;
  }
${code}`;
        }

        allCode.push(`${head}
${receiver}
  let target = data[spritly.runtime.Symbols.target];
  if(target == null) {
    target = receiver || sender;
  }
${code}
});`);
        headless.dispose();
        xml.removeChild(block);
      }
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
      if(preload_res) {
        allCode.push(`spritly.runtime.scene.preload(...${JSON.stringify(preload_res)})
  .then(() => spritly.runtime.Signal.send('START', spritly.runtime.scene));
`);
      } else {
        allCode.push("spritly.runtime.Signal.send('START', spritly.runtime.scene);\n");
      }
      if(procedures) {
        return [procedures.replace(/^var\s.*\n/img, ''), ...allCode];
      }
      return allCode;
    }

    function showXml() {
      const xml = Blockly.Xml.workspaceToDom(workspace);
      let code = xml.innerHTML;
      if(preload_res) {
        const resources = [];
        preload_res.forEach((res) => {
          if(Array.isArray(res)) {
            resources.push(`<resource type="texture_packer" texture="${res[0]}" data="${res[1]}"/>`);
          } else if(res.id === res.src) {
            resources.push(`<resource type="image" src="${res.src}"/>`);
          } else {
            resources.push(`<resource type="image" src="${res.src}" id="${res.id}"/>`);
          }
        });
        code = `<preload>${resources.join('')}</preload>${code}`;
      }
      code = `<xml toolbox="${toolbox}">${code}</xml>`;
      let indent = 0;
      let code2 = code.replace(/></g, '>\n<');
      code2 = code2.split(/\n/g).map((line) => {
        let ret = line;
        if(/^<\//.test(line)) {
          indent -= 2;
        }
        if(indent > 0) {
          ret = `${(new Array(indent + 1)).join(' ')}${line}`;
        }
        if(!(/(<\/\w+>|\/>)$/.test(line))) {
          indent += 2;
        }
        return ret;
      }).join('\n');
      const wnd = window.open('', '__blank', '');
      wnd.document.write(`<pre class="prettyprint" lang-xml>${code2.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`);
      wnd.document.write('<script>var sel = document.createElement("script"); sel.src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"; window.onload = function(){document.body.appendChild(sel)};<\/script>'); // eslint-disable-line
      wnd.document.close();
    }

    function showCode() {
      // Generate JavaScript code and display it.
      /* eslint-disable */
      const comment = `/** 
  Generated by spritly ${(new Date()).toLocaleString()};
  Usage: 
  <script src="https://unpkg.com/spritejs/dist/spritejs.min.js"><\/script>
  <script src="https://unpkg.com/spritly/dist/spritly-runtime.min.js"><\/script>
  <div id="stage" style="width:100%;height:100%;"></div>
*/`; /* eslint-enable */
      const code = [comment, 'spritly.runtime.use(spritejs);', ...getCode()].join('\n\n');
      const wnd = window.open('', '__blank', '');
      wnd.document.write(`<pre class="prettyprint" lang-js>${code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`);
      wnd.document.write('<script>var sel = document.createElement("script"); sel.src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"; window.onload = function(){document.body.appendChild(sel)};<\/script>'); // eslint-disable-line
      wnd.document.close();
    }

    function runCode() {
      try {
        Dropdown.clear();
        const codes = getCode();
        const code = codes.join('');
        window.frames[0].exec(code);
      } catch (e) {
        console.error(e);
        // alert(e);
      }
    }

    window.runCode = runCode;
    window.showCode = showCode;
    window.showXml = showXml;

    function setCollapsedAll(block, isCollapsed) {
      let nextBlock = block;

      do {
        nextBlock = nextBlock.getNextBlock();
        if(nextBlock) nextBlock.setCollapsed(isCollapsed);
      } while(nextBlock);
    }

    function debounce(action, delay = 300) {
      let timer = null;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
          action.apply(this, args);
        }, delay);
      };
    }

    await loadStartBlocks();
    update();

    const links = document.getElementById('links');
    links.addEventListener('click', async (evt) => {
      evt.preventDefault();
      if(evt.target.tagName === 'A') {
        const link = evt.target;
        window.location.href = link.href;
        await loadStartBlocks();
      }
    });

    document.addEventListener('keydown', (evt) => {
      const sendbox = window.frames[0];
      if(sendbox.spritly) {
        sendbox.spritly.runtime.dispatchEvent('KEYDOWN', document, evt);
      }
    });
  
    document.addEventListener('keyup', (evt) => {
      const sendbox = window.frames[0];
      if(sendbox.spritly) {
        sendbox.spritly.runtime.dispatchEvent('KEYUP', document, evt);
      }
    });
  }());
  </script>
</body>
</html>